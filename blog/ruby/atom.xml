<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | RailsとRubyとVimのブログ]]></title>
  <link href="http://alpaca.tc/blog/ruby/atom.xml" rel="self"/>
  <link href="http://alpaca.tc/"/>
  <updated>2014-02-25T18:53:12+09:00</updated>
  <id>http://alpaca.tc/</id>
  <author>
    <name><![CDATA[alpaca-tc]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gemを書くときに知っておきたい3つの事]]></title>
    <link href="http://alpaca.tc/blog/ruby/i-have-almost-finished-implementing-comment-parser.html"/>
    <updated>2014-02-18T20:52:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/i-have-almost-finished-implementing-comment-parser</id>
    <content type="html"><![CDATA[<p>先日から書き続けていた<a href="https://github.com/alpaca-tc/comment_extractor">CommentExtractor</a>が、大枠完成しました。</p>

<p><img class="image_on_frame center" src="/images/blog/i-have-almost-finished-implementing-comment-parser/capture.png" title="CommentExtractor" ></p>

<p>さて、今回Gemを書くときに役に立った、便利なTipsを幾つか紹介します！</p>

<!-- more -->


<p>内容はバラバラです。笑</p>

<ol>
<li>READMEに視覚情報を追加する</li>
<li>RubyGemsからGemを削除する</li>
<li>RSpecをキレイに書く</li>
</ol>


<h2>1.READMEに視覚情報を追加する</h2>

<p>READMEには視覚的なバッヂを追加出来ます。Gemを書くときには、ぜひとも入れておきたい情報ですね。</p>

<ul>
<li><a href="http://badge.fury.io/rb/comment_extractor"><img src="https://badge.fury.io/rb/comment_extractor.png" alt="Gem Version" /></a></li>
<li><a href="https://travis-ci.org/alpaca-tc/comment_parser"><img src="https://travis-ci.org/alpaca-tc/comment_extractor.png?branch=v1.0.0" alt="Build Status" /></a></li>
<li><a href="https://coveralls.io/r/alpaca-tc/comment_extractor?branch=v1.0.0"><img src="https://coveralls.io/repos/alpaca-tc/comment_extractor/badge.png?branch=v1.0.0" alt="Coverage Status" /></a></li>
</ul>


<p>もちろん、登録すれば無料で作ることが出来ます。</p>

<p>詳しくは<a href="http://elgalu.github.io/2013/add-achievement-badges-to-your-gem-readme/">コチラの記事</a>を読んでみましょう。</p>

<h2>2.RubyGemsからGemを削除する</h2>

<p>間違えてRubyGemsにPushしてしまった！</p>

<p>そんなときに便利なyankコマンド。意外と知られていない。</p>

<p><code>sh
gem yank gem_name -v 1.0.0
</code></p>

<p>ただ、これをやっても論理削除されるだけのようですねぇ。多分。</p>

<p>このバージョン使うなよ！新しいの使えよ！ってときに使うコマンドだと思います。</p>

<h2>3.RSpecをキレイに書く</h2>

<p>RSpecをキレイに書く方法は、ある程度伝統があります。</p>

<ul>
<li><a href="http://betterspecs.org/">BetterSpecs</a></li>
<li><a href="http://bitfluxx.com/2011/05/23/some-rspec-tips-and-best-practices.html">Some RSpec Tips and Best Practices</a></li>
</ul>


<p>今回は、ある程度RSpecを書ける人向けに、検索してもあまり出てこない情報(検索しにくい？)を提供したいと思います。</p>

<h3>Syntaxについて</h3>

<h4>be_truthy, be_falsy</h4>

<p>RSpecが新しくなって、<code>be_true</code>, <code>be_false</code>→<code>be_truthy</code>, <code>be_falsy</code>となりました。
今までは、厳密に<code>true</code>で無くてもテストが通っちゃいましたからね。</p>

<h4>現在の主題であるクラスを取得する</h4>

<p>RSpecでは<code>described_class</code>というメソッドを使用出来ます。
<code>describe KlassName do...</code>で指定したKlassNameが格納されます。</p>

<p>これを使えば、クラス名に依存せずにテストを書く事ができますね。</p>

<h4>ExampleGroupを作る</h4>

<p>ご存知の通り、Railsのテストではcontroller, model, viewで使えるメソッドが大きく異なります。
それは、RSpecのexample_groupという機能を使って、テストの種類を元にModuleをincludeしているからです。</p>

<p>これを使えば、複数のファイルで共通する内容を簡単に記述する事が出来ます。
次のような感じですね。</p>

<p>```ruby</p>

<h1>spec_helper.rb</h1>

<p>RSpec.configure do |config|
  config.include ExampleGroupModuleName, type: :optional, example_group: {</p>

<pre><code>file_path: Regexp.compile(%w[spec comment_extractor extractor .*.rb].join('[\\\/]'))
</code></pre>

<p>  }
end
```</p>

<p>```ruby
RSpec.configure do |config|
  config.add_setting :source_code_path, default: &lsquo;spec/assets/source_code&rsquo;
end</p>

<p>module ExampleGroupModuleName
  def source_code_path(file_name = nil)</p>

<pre><code>dir = RSpec.configuration.source_code_path
file_name ? "#{dir}/#{file_name}" : dir
</code></pre>

<p>  end</p>

<p>  def self.included(k)</p>

<pre><code>k.class_eval do
  let(:instance) { described_class.new(source_code) }
  let(:source_code) { source_code_path(file_name) }

  describe '.new' do
    subject { instance }
    let(:file_name) { 'filename.rb' }
    it { expect { subject }.to_not raise_error }
  end
end
</code></pre>

<p>  end
end
```</p>

<p>これを使えば、まとまったテストをスッキリ書く事ができますね。</p>

<h2>まとめ</h2>

<p>ざっくばらんに書きました。
Gemを作るのは簡単なので、みなさんも作ってみてください！</p>

<p>では！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ここまで出来る！RubyのSplat Operatorまとめ]]></title>
    <link href="http://alpaca.tc/blog/ruby/how-to-use-star.html"/>
    <updated>2014-02-12T04:16:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/how-to-use-star</id>
    <content type="html"><![CDATA[<p>Splat Operatorとは、<code>*</code>のことです</p>

<p><img class="image_on_frame center" src="/images/blog/how-to-use-star/capture.png" title="SplatOperator" ></p>

<p>この前、友人にコードレビューしてもらっていたら</p>

<p>「え、Rubyってこんな書き方出来るんですか？」と言われて、「知らない人もいるんだなぁ」と思ったので簡単なまとめ</p>

<!-- more -->


<h1>Splat Operatorの色んな使い方</h1>

<p>Splat Operatorは、応用の幅が広いです。</p>

<p>結構当たり前だと思っていましたが、コード読書しないと見る機会は少ないかも。</p>

<h2>1-1. 配列に変換する</h2>

<p>まずは基本編。配列に変換してやりましょう</p>

<p>文字列やsymbolは<code>.to_a</code>が無いですが、<code>*</code>を使えばどの変数でも配列に出来ちゃいます。</p>

<p>```ruby
string = *&ldquo;string&rdquo;
p string #=> [&ldquo;string&rdquo;]</p>

<p>symbol = *:symbol
p symbol #=> [:symbol]</p>

<p>hash = *{ hash: nil }
p hash #=> [[:hash, nil]]</p>

<p>range = *(1..10)
p range #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```</p>

<h2>1-2. 親クラスの引数を気にしない</h2>

<p>またまた基本編。<code>*</code>を引数に指定してやれば、親クラスの引数は知らなくても大丈夫。</p>

<p><code>*</code>だけで出来ることを知らない人はいるかも。</p>

<p>```ruby
class Child &lt; Super
  def initialize(*)</p>

<pre><code>super
</code></pre>

<p>  end
end
```</p>

<h2>1-3. 間の引数をまとめる</h2>

<p>引数の最後にSplat Operatorを使うことはよくありますが、間はなかなか見ないですね。</p>

<p>blockで引数を取るときに、間の引数をまとめる事が出来ます。</p>

<p>メソッドやProc,lambdaでも同様の動作です。</p>

<p>```ruby
list = [[:first, :second, :third, :fourth, :fifth]]
list.each do |first, *mid, last|
  p first  #=> :first
  p mid    #=> [:second, :third, :fourth]
  p last   #=> :fifth
end</p>

<h1>もちろん、こんなことも出来ます</h1>

<p>first, *other = [1, 2, 3]
p other #=> [2, 3]
```</p>

<h2>1-4. <code>**</code>を使う</h2>

<p>キーワード引数って、まだあまり普及してないですね。互換性が気になるからだろうか？</p>

<p><code>**</code>はキーワード引数を取るときに、余った引数をまとめます。</p>

<p><code>ruby
def hoge(first: 1, second: 2, **others)
  p others #=&gt; { third: 3 }
end
hoge(first: 1, second: 2, third: 3)
</code></p>

<p>多分これはSplat Operatorと呼ばない。</p>

<h2>まとめ</h2>

<p>こんな書き方が出来るSplat Operatorって本当に便利ね！</p>

<p>( ﾟ∀ﾟ)o彡ﾟんぎもぢいい!!</p>

<p>```ruby
class Integer
  def upto_with_exception(to, **options)</p>

<pre><code>exception_array = *options[:except] #=&gt; nilでも何でもおかまいなし！
exceptions = Hash[exception_array.zip]

self.upto(to) { |i| p i unless exceptions.has_key?(i) }
</code></pre>

<p>  end
end</p>

<p>1.upto_with_exception(5) #=> 1, 2, 3, 4, 5
1.upto_with_exception(5, except: 3) #=> 1, 2, 4, 5
1.upto_with_exception(5, except: 2..3) #=> 1, 4, 5
1.upto_with_exception(5, except: [4, 5]) #=> 1, 2, 3
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[久しぶりにGemを書いている]]></title>
    <link href="http://alpaca.tc/blog/ruby/create-strip-comment.html"/>
    <updated>2014-02-10T12:33:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/create-strip-comment</id>
    <content type="html"><![CDATA[<p>最近、久しぶりにGemを書いてます。</p>

<p>去年から<a href="https://github.com/nhmood/watson-ruby">watson-ruby</a>というinline issue manager貢献してます。</p>

<p>watsonは凄い便利なんですが、コードがかなりアレなのです&hellip;。</p>

<p>「全部リファクタリングさせてくれー！」って言っても、まだやりたい作業があるらしく「ブランチ切るから、もう少し待ってて:)」と言われたっきり&hellip;</p>

<p>うーむ、、なかなか全部は触れないので、とりあえず一番やっかいな部分だけ汎用的にすべく自作しました。</p>

<!-- more -->


<h2>どんなGem?</h2>

<p>あらゆるプログラムソースを読み取って、<strong>コメント行のみを取り出すGem</strong>です。watsonでは、このコメント行を読み取って、todoの管理を行っています。</p>

<p>最近のwatsonのPRを見ても、対応ファイルの追加(正規表現の追記)ばかりなのです。こんなもの、他のGemにくれてしまえ！</p>

<p>どんなファイルタイプであれ、扱うのはコメントという概念なのだから、委譲して抽象化しちゃいましょう。</p>

<h2>何が出来るようになるんだい？</h2>

<p>あらゆるプログラムのソースコードをパースして、コメント行だけを抽象的に扱う事が出来ます。</p>

<p>読み取って、何らかの処理をすることが出来ます。</p>

<p>```ruby</p>

<h1>今のところはこんな感じ。</h1>

<h1>Gem名やmethod名は変更します</h1>

<p>require &lsquo;strip_comment&rsquo;</p>

<p>path = &lsquo;/path/to/file&rsquo;
file = StripComment::FileObject.new(path)
parser = StripComment::Parser.for(file)
parser.scan
parser.comments # => [StripComment::CodeObject::Comment, &hellip;]
```</p>

<p>簡単に思いつく限りの用途はこんな感じ。</p>

<ul>
<li>英語のコメントの文法チェック / 翻訳</li>
<li><code>[review - @alpaca-tc ここ見ておいて！]</code>というコメントにGit post-hookをかけて、ダイレクトメッセージを送る</li>
<li>iftttとの連携</li>
</ul>


<p>他にも色々出来そうですね。</p>

<h2>Vimでテスト</h2>

<p>さっそくVimと連携してみました。</p>

<p><img class="image_on_frame center" src="/images/blog/create-strip-comment/comment.gif" title="comment.vimデモ" ></p>

<p>コメント行を取り出して、Gingerで文法チェックしています。</p>

<h2>まとめ</h2>

<p>あとは対応ファイルを増やして、リファクタリングしたら完成です。
今<code>StripComment</code>という名前なんだけど、絶対違うよね。(´・ω・｀)良い名前が思いつかない</p>

<p>終わったら誰か、コードレビューして欲しいなぁ！ヽ(・∀・ )ﾉわーい</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyのクラス変数について詰まったのでヘルプ]]></title>
    <link href="http://alpaca.tc/blog/ruby/ruby-class-variable.html"/>
    <updated>2013-12-16T01:10:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/ruby-class-variable</id>
    <content type="html"><![CDATA[<p>基本的に、仕事でクラス変数を扱うことはほぼ無いです。</p>

<p>今回は遊びのコードを書いていて、悩んだことをまとめました。</p>

<!-- more -->


<h1>Rubyのクラス変数の扱いが難しい&hellip;。</h1>

<p>これ、結構Ruby書いている自分でも初めて遭遇して悩む問題だった。</p>

<p>まず、次のような動くコードを書いてみた。</p>

<p>```ruby
class Base; end</p>

<p>class Node &lt; Base
  @@val = &lsquo;Node&rsquo;
end</p>

<p>class Branch &lt; Base
  @@val = &lsquo;Branch&rsquo;
end</p>

<p>p Node.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Node&rsquo;
p Branch.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Branch&rsquo;
```</p>

<p>ふむ、それぞれの派生クラスでクラス変数が使えますね。</p>

<p>では、続いて基底クラスにもクラス変数を与えてみる。</p>

<p>```ruby
class Base
  @@val = nil
end</p>

<p>class Node &lt; Base
  @@val = &lsquo;Node&rsquo;
end</p>

<p>class Branch &lt; Base
  @@val = &lsquo;Branch&rsquo;
end</p>

<p>p Node.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Branch&rsquo;
p Branch.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Branch&rsquo;
```</p>

<p>Ooops!!! 派性クラス内のクラス変数が、基底クラス変数を参照しよる！！</p>

<h2>解決編</h2>

<p>やりたいことは、派生クラスの子クラスに共通の変数を持たせるということ。</p>

<p>うーん、意外と難しい！</p>

<p>どうもクラス変数という感じではなくなるけれど、こうするしかないのだろうか&hellip;。</p>

<p>メソッドにしてみたら、とっても気持ちが悪い。</p>

<p>```ruby
class Base
  class &lt;&lt; self</p>

<pre><code>private

def val
  'Base'
end
</code></pre>

<p>  end
end</p>

<p>class Node &lt; Base
  class &lt;&lt; self</p>

<pre><code>private

def val
  'Node'
end
</code></pre>

<p>  end
end</p>

<p>class Branch &lt; Base
  class &lt;&lt; self</p>

<pre><code>private

def val
  'Branch'
end
</code></pre>

<p>  end
end</p>

<p>p Node.send(:val) #=> &lsquo;Node&rsquo;
p Branch.send(:val) #=> &lsquo;Branch&rsquo;
```</p>

<p>これだと、一応コードとして動く。 ただ、<strong>これは無いだろ感</strong>あるよね。</p>

<p>しかし、クラスインスタンス変数だと継承されないし、こうするしかないのかなぁ。</p>

<p><strong>だれか正しい方法があれば、教えてください！</strong> >_&lt;</p>

<h3>追記</h3>

<p>思いついたんだけど、継承するときにクラスインスタンス変数を渡せばいいのかな？</p>

<p>どうでしょう。</p>

<p>```ruby
class Base
  @val = &lsquo;Base&rsquo;</p>

<p>  def self.inherited(klass)</p>

<pre><code>klass.instance_variable_set('@val', @val)
</code></pre>

<p>  end
end</p>

<p>class Node &lt; Base; end
class Branch &lt; Base; end</p>

<p>p Node.instance_variable_get(&lsquo;@val&rsquo;) #=> &lsquo;Base&rsquo;
p Branch.instance_variable_get(&lsquo;@val&rsquo;) #=> &lsquo;Base&rsquo;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[インラインTODO管理のWatsonを使う]]></title>
    <link href="http://alpaca.tc/blog/ruby/how-to-use-watson.html"/>
    <updated>2013-12-03T23:49:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/how-to-use-watson</id>
    <content type="html"><![CDATA[<p>最近、Githubのトレンドにも入っていた<a href="http://goosecode.com/watson/">Watson</a>を紹介します。</p>

<!-- more -->


<p><img class="image_on_frame center" src="/images/blog/watson.png" title="watsonのデモ" ></p>

<h2>インラインTODO管理とは何か</h2>

<p>もしあなたがエンジニアなら、次のようなコメントを見たことがあると思います。</p>

<p>```ruby
class ApplicationController &lt; ActionController::Base
  def logged_in?</p>

<pre><code># TODO 管理ユーザーと処理を分ける
...
</code></pre>

<p>  end
end
```</p>

<p>このように、コード内には至る所にコメントが書かれています。
単なるコードの説明に限らず、修正が必要な内容を記述したものも多くあります。</p>

<p>しかしながら、しばしばこういったコメントは放置され、コードの中に埋もれたままになってしまうこともあります。</p>

<p>Watsonは、コード内に書かれたコメントを走査し、近代的な管理ツールに流し込むことでIssueを管理するツールです。</p>

<h2>どうやって使うのか</h2>

<p>watsonを使って、コード内に記述されたコメントを洗い出して、GithubのIssueに登録してみましょう。</p>

<h3>ステップ1: watsonのインストール</h3>

<p><code>sh
$ gem install watson
</code></p>

<h3>ステップ2: watsonの初期化</h3>

<p>```sh
$ cd path/to/project_dir
$ watson</p>

<h1>一旦&lt;Ctrl-C>で終了してください。</h1>

<p>```</p>

<p><code>.watsonrc</code>が自動的に作成されるので、プロジェクトに合わせて走査するディレクトリなどを設定します。</p>

<p>例として、Railsプロジェクト用の<a href="https://gist.github.com/7770689">.watsonrc</a>を貼付けておきます。</p>

<h3>ステップ3: watsonの実行！！</h3>

<p>watsonを使うときは、独自のタグを使ってコメントを書いておきます。</p>

<ul>
<li><code>[todo] - タスクの内容を記入する</code></li>
<li><code>[review] - 他の人に意見を求めるような内容を記入する</code></li>
<li><code>[fix] - バグの内容を記入する</code></li>
</ul>


<p>試しに、適当なファイルを開いて、上記のようなフォーマットでコメントを記入してみてください。</p>

<p>後は、再度<code>watson</code>と打って実行！</p>

<p>めでたしめでたし。
プロジェクト内のTODOなどが、一覧で出力されます。</p>

<h3>ステップ4: githubへIssue登録する</h3>

<p>先ほどの出力した内容を、Githubへ一括同期しましょう。</p>

<p>まず、Githubのリポジトリをwatsonに認識させます</p>

<p><code>sh
$ watson --remote github
</code></p>

<p>英語のコメントに沿って、情報を入力していきましょう。</p>

<p>続いて、Issueを登録します。</p>

<p><code>sh
$ watson --update
</code></p>

<p>処理が終わると、Githubのissueへの登録が完了です。</p>

<p><img class="image_on_frame center" src="/images/blog/watson_issue_preview.png" title="githubのissueプレビュー" ></p>

<h2>まとめ</h2>

<p>watsonは先月ぐらいに注目され始めた新しいプロジェクトです。</p>

<p>今後は、コメントを活用して様々な処理を行えるように拡張されると思うので、動向が楽しみですね。</p>

<h3>watsonの現状</h3>

<ul>
<li>Ruby初心者の人が作ったため、コードがよろしくない(PR中)</li>
<li>今のところ対応している管理ツールは、githubとbitbucket。</li>
<li>安定版に必要な機能が未実装。なので、新機能のPRがなかなか取り入れられない状況。数ヶ月待たないといけなさそう。</li>
<li>対応しているファイルタイプがまだ少ない</li>
</ul>

]]></content>
  </entry>
  
</feed>



