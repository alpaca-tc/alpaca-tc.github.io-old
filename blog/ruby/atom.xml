<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | RailsとRubyとVimのブログ]]></title>
  <link href="http://alpaca.tc/blog/ruby/atom.xml" rel="self"/>
  <link href="http://alpaca.tc/"/>
  <updated>2014-02-10T12:59:00+09:00</updated>
  <id>http://alpaca.tc/</id>
  <author>
    <name><![CDATA[alpaca-tc]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[久しぶりにGemを書いている]]></title>
    <link href="http://alpaca.tc/blog/ruby/create-strip-comment.html"/>
    <updated>2014-02-10T12:33:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/create-strip-comment</id>
    <content type="html"><![CDATA[<p>最近、久しぶりにGemを書いてます。</p>

<p>去年から<a href="https://github.com/nhmood/watson-ruby">watson-ruby</a>というinline issue manager貢献してます。</p>

<p>watsonは凄い便利なんですが、コードがかなりアレなのです&hellip;。</p>

<p>「全部リファクタリングさせてくれー！」って言っても、まだやりたい作業があるらしく「ブランチ切るから、もう少し待ってて:)」と言われたっきり&hellip;</p>

<p>うーむ、、なかなか全部は触れないので、とりあえず一番やっかいな部分だけ汎用的にすべく自作しました。</p>

<h2>どんなGem?</h2>

<p>あらゆるプログラムソースを読み取って、<strong>コメント行のみを取り出すGem</strong>です。watsonでは、このコメント行を読み取って、todoの管理を行っています。</p>

<p>最近のwatsonのPRを見ても、対応ファイルの追加(正規表現の追記)ばかりなのです。こんなもの、他のGemにくれてしまえ！</p>

<p>どんなファイルタイプであれ、扱うのはコメントという概念なのだから、委譲して抽象化しちゃいましょう。</p>

<h2>何が出来るようになるんだい？</h2>

<p>あらゆるプログラムのソースコードをパースして、コメント行だけを抽象的に扱う事が出来ます。</p>

<p>読み取って、何らかの処理をすることが出来ます。</p>

<p>```ruby</p>

<h1>今のところはこんな感じ。</h1>

<h1>Gem名やmethod名は変更します</h1>

<p>require &lsquo;strip_comment&rsquo;</p>

<p>path = &lsquo;/path/to/file&rsquo;
file = StripComment::FileObject.new(path)
parser = StripComment::Parser.for(file)
parser.scan
parser.comments # => [StripComment::CodeObject::Comment, &hellip;]
```</p>

<p>簡単に思いつく限りの用途はこんな感じ。</p>

<ul>
<li>英語のコメントの文法チェック / 翻訳</li>
<li><code>[review - @alpaca-tc ここ見ておいて！]</code>というコメントにGit post-hookをかけて、ダイレクトメッセージを送る</li>
<li>iftttとの連携</li>
</ul>


<p>他にも色々出来そうですね。</p>

<h2>Vimでテスト</h2>

<p>さっそくVimと連携してみました。</p>

<p><img class="image_on_frame center" src="/images/blog/create-strip-comment/comment.gif" title="comment.vimデモ" ></p>

<p>コメント行を取り出して、Gingerで文法チェックしています。</p>

<h2>まとめ</h2>

<p>あとは対応ファイルを増やして、リファクタリングしたら完成です。</p>

<p>終わったら誰か、コードレビューして欲しいなぁ！ヽ(・∀・ )ﾉわーい</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyのクラス変数について詰まったのでヘルプ]]></title>
    <link href="http://alpaca.tc/blog/ruby/ruby-class-variable.html"/>
    <updated>2013-12-16T01:10:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/ruby-class-variable</id>
    <content type="html"><![CDATA[<p>基本的に、仕事でクラス変数を扱うことはほぼ無いです。</p>

<p>今回は遊びのコードを書いていて、悩んだことをまとめました。</p>

<!-- more -->


<h1>Rubyのクラス変数の扱いが難しい&hellip;。</h1>

<p>これ、結構Ruby書いている自分でも初めて遭遇して悩む問題だった。</p>

<p>まず、次のような動くコードを書いてみた。</p>

<p>```ruby
class Base; end</p>

<p>class Node &lt; Base
  @@val = &lsquo;Node&rsquo;
end</p>

<p>class Branch &lt; Base
  @@val = &lsquo;Branch&rsquo;
end</p>

<p>p Node.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Node&rsquo;
p Branch.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Branch&rsquo;
```</p>

<p>ふむ、それぞれの派生クラスでクラス変数が使えますね。</p>

<p>では、続いて基底クラスにもクラス変数を与えてみる。</p>

<p>```ruby
class Base
  @@val = nil
end</p>

<p>class Node &lt; Base
  @@val = &lsquo;Node&rsquo;
end</p>

<p>class Branch &lt; Base
  @@val = &lsquo;Branch&rsquo;
end</p>

<p>p Node.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Branch&rsquo;
p Branch.class_variable_get(&lsquo;@@val&rsquo;) #=> &lsquo;Branch&rsquo;
```</p>

<p>Ooops!!! 派性クラス内のクラス変数が、基底クラス変数を参照しよる！！</p>

<h2>解決編</h2>

<p>やりたいことは、派生クラスの子クラスに共通の変数を持たせるということ。</p>

<p>うーん、意外と難しい！</p>

<p>どうもクラス変数という感じではなくなるけれど、こうするしかないのだろうか&hellip;。</p>

<p>メソッドにしてみたら、とっても気持ちが悪い。</p>

<p>```ruby
class Base
  class &lt;&lt; self</p>

<pre><code>private

def val
  'Base'
end
</code></pre>

<p>  end
end</p>

<p>class Node &lt; Base
  class &lt;&lt; self</p>

<pre><code>private

def val
  'Node'
end
</code></pre>

<p>  end
end</p>

<p>class Branch &lt; Base
  class &lt;&lt; self</p>

<pre><code>private

def val
  'Branch'
end
</code></pre>

<p>  end
end</p>

<p>p Node.send(:val) #=> &lsquo;Node&rsquo;
p Branch.send(:val) #=> &lsquo;Branch&rsquo;
```</p>

<p>これだと、一応コードとして動く。 ただ、<strong>これは無いだろ感</strong>あるよね。</p>

<p>しかし、クラスインスタンス変数だと継承されないし、こうするしかないのかなぁ。</p>

<p><strong>だれか正しい方法があれば、教えてください！</strong> >_&lt;</p>

<h3>追記</h3>

<p>思いついたんだけど、継承するときにクラスインスタンス変数を渡せばいいのかな？</p>

<p>どうでしょう。</p>

<p>```ruby
class Base
  @val = &lsquo;Base&rsquo;</p>

<p>  def self.inherited(klass)</p>

<pre><code>klass.instance_variable_set('@val', @val)
</code></pre>

<p>  end
end</p>

<p>class Node &lt; Base; end
class Branch &lt; Base; end</p>

<p>p Node.instance_variable_get(&lsquo;@val&rsquo;) #=> &lsquo;Base&rsquo;
p Branch.instance_variable_get(&lsquo;@val&rsquo;) #=> &lsquo;Base&rsquo;
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[インラインTODO管理のWatsonを使う]]></title>
    <link href="http://alpaca.tc/blog/ruby/how-to-use-watson.html"/>
    <updated>2013-12-03T23:49:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/how-to-use-watson</id>
    <content type="html"><![CDATA[<p>最近、Githubのトレンドにも入っていた<a href="http://goosecode.com/watson/">Watson</a>を紹介します。</p>

<!-- more -->


<p><img class="image_on_frame center" src="/images/blog/watson.png" title="watsonのデモ" ></p>

<h2>インラインTODO管理とは何か</h2>

<p>もしあなたがエンジニアなら、次のようなコメントを見たことがあると思います。</p>

<p>```ruby
class ApplicationController &lt; ActionController::Base
  def logged_in?</p>

<pre><code># TODO 管理ユーザーと処理を分ける
...
</code></pre>

<p>  end
end
```</p>

<p>このように、コード内には至る所にコメントが書かれています。
単なるコードの説明に限らず、修正が必要な内容を記述したものも多くあります。</p>

<p>しかしながら、しばしばこういったコメントは放置され、コードの中に埋もれたままになってしまうこともあります。</p>

<p>Watsonは、コード内に書かれたコメントを走査し、近代的な管理ツールに流し込むことでIssueを管理するツールです。</p>

<h2>どうやって使うのか</h2>

<p>watsonを使って、コード内に記述されたコメントを洗い出して、GithubのIssueに登録してみましょう。</p>

<h3>ステップ1: watsonのインストール</h3>

<p><code>sh
$ gem install watson
</code></p>

<h3>ステップ2: watsonの初期化</h3>

<p>```sh
$ cd path/to/project_dir
$ watson</p>

<h1>一旦&lt;Ctrl-C>で終了してください。</h1>

<p>```</p>

<p><code>.watsonrc</code>が自動的に作成されるので、プロジェクトに合わせて走査するディレクトリなどを設定します。</p>

<p>例として、Railsプロジェクト用の<a href="https://gist.github.com/7770689">.watsonrc</a>を貼付けておきます。</p>

<h3>ステップ3: watsonの実行！！</h3>

<p>watsonを使うときは、独自のタグを使ってコメントを書いておきます。</p>

<ul>
<li><code>[todo] - タスクの内容を記入する</code></li>
<li><code>[review] - 他の人に意見を求めるような内容を記入する</code></li>
<li><code>[fix] - バグの内容を記入する</code></li>
</ul>


<p>試しに、適当なファイルを開いて、上記のようなフォーマットでコメントを記入してみてください。</p>

<p>後は、再度<code>watson</code>と打って実行！</p>

<p>めでたしめでたし。
プロジェクト内のTODOなどが、一覧で出力されます。</p>

<h3>ステップ4: githubへIssue登録する</h3>

<p>先ほどの出力した内容を、Githubへ一括同期しましょう。</p>

<p>まず、Githubのリポジトリをwatsonに認識させます</p>

<p><code>sh
$ watson --remote github
</code></p>

<p>英語のコメントに沿って、情報を入力していきましょう。</p>

<p>続いて、Issueを登録します。</p>

<p><code>sh
$ watson --update
</code></p>

<p>処理が終わると、Githubのissueへの登録が完了です。</p>

<p><img class="image_on_frame center" src="/images/blog/watson_issue_preview.png" title="githubのissueプレビュー" ></p>

<h2>まとめ</h2>

<p>watsonは先月ぐらいに注目され始めた新しいプロジェクトです。</p>

<p>今後は、コメントを活用して様々な処理を行えるように拡張されると思うので、動向が楽しみですね。</p>

<h3>watsonの現状</h3>

<ul>
<li>Ruby初心者の人が作ったため、コードがよろしくない(PR中)</li>
<li>今のところ対応している管理ツールは、githubとbitbucket。</li>
<li>安定版に必要な機能が未実装。なので、新機能のPRがなかなか取り入れられない状況。数ヶ月待たないといけなさそう。</li>
<li>対応しているファイルタイプがまだ少ない</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guard-shellが便利だった話]]></title>
    <link href="http://alpaca.tc/blog/ruby/the-story-about-guard-shell.html"/>
    <updated>2013-11-23T01:34:00+09:00</updated>
    <id>http://alpaca.tc/blog/ruby/the-story-about-guard-shell</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/guard/guard">Guard</a>って便利ですよねー。</p>

<p>あの、ファイルをwatchして、変更を検知したらアクションをグルグル回すやつです。</p>

<p>最近Vimの開発をしていて、あー変更と同時にコンパイルしてくれたらいいのになぁ。</p>

<p>Guardを使って実現してみました。</p>

<!-- more -->


<h1>guard + guard-shell</h1>

<p>おなじみのGuardにshellコマンドを実行できるようにします。</p>

<p><em>GuardでC言語を自動コンパイル！！！</em></p>

<p>```ruby</p>

<h1>Gemfile</h1>

<p>source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<p>gem &lsquo;guard&rsquo;
gem &lsquo;guard-shell&rsquo;
```</p>

<p>```ruby</p>

<h1>Guardfile</h1>

<p>group :vim3 do
  guard :shell do</p>

<pre><code>target_dir = 'vim-3\.0/src'
watch(%r!^#{target_dir}/(.+)\.(c|h)!) do
  `cd #{target_dir} &amp;&amp; make`
  `cd #{target_dir} &amp;&amp; make debug`
end
</code></pre>

<p>  end</p>

<p>  &hellip;
end
```</p>

<p>ポイントは、<em>group</em>と<em>guard :shell &hellip;</em>ですね。</p>

<h2>guardのDSL <em>group</em></h2>

<p>groupのDSLを使うと、guardの設定を切り替えることができます。</p>

<p>例えば、バージョン毎にgroupで設定をわけておけば、不必要な部分でguardが動作することを防ぐことができます。
僕の場合は、vimのバージョン毎に設定を切り替えることで不必要なコンパイルを防いでいます。</p>

<p>また、分けてあるgroupを切り替えるときは、guardのコンソールで<code>scope vim3</code>と打てば切り替わります。</p>

<p>(起動時にscopeを指定する場合は、<code>guard --group vim3</code>)</p>

<h2>guard-shellを使う</h2>

<p>guard-shellは、ファイルの変更をフックにしてshellコマンドを実行するgemです。</p>

<p>と、あたかもshellに特化したネーミングですが、実際はただ単にwatchに渡したブロックを評価するだけのシンプルなやつです。</p>

<p>下記のようにすれば、ファイルが保存されたと同時に<code>hogepiyoooooooooooooo</code>と教えてくれます。
わーい。</p>

<p>```ruby</p>

<h1>Guardfile</h1>

<p>guard :shell do
  watch(/.*/) { |m| <code>say hogepiyoooooooooooooo</code> }
end
```</p>

<h2>まとめ</h2>

<p><em>guard-shell便利。</em></p>

<p>(ホゲピヨーーーーーって言うのかと思ったら、「ホージピュゥ」って何か冷めた感じに返された。。。)</p>
]]></content>
  </entry>
  
</feed>



