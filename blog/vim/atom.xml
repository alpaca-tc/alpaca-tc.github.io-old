<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | RailsとRubyとVimのブログ]]></title>
  <link href="http://alpaca-tc.github.io/blog/vim/atom.xml" rel="self"/>
  <link href="http://alpaca-tc.github.io/"/>
  <updated>2014-01-01T18:46:36+09:00</updated>
  <id>http://alpaca-tc.github.io/</id>
  <author>
    <name><![CDATA[alpaca-tc]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2013年に作ったVimプラグイン達]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/vim-plugins-2013.html"/>
    <updated>2013-12-29T22:54:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/vim-plugins-2013</id>
    <content type="html"><![CDATA[<p>今年も残すところあと僅か！あぁ、Vimにどっぷりの一年でした。</p>

<p><strong>今年書いたプラグインを紹介しまーす！</strong></p>

<!-- more -->


<p>振り返ると、一年で人はここまでVimmerとして成長できるのかと驚くばかりです。(まだまだ未熟者ですが)</p>

<h1>14個のVimプラグイン達</h1>

<p>今年書いたプラグインは14個以上でした。
1年以内の出来事とは思えないぐらい、それぞれが思い出深いですね。。。</p>

<p>外部に発表していなかったプラグインもあるので、余力があれば試してみてください。</p>

<h2><a href="https://github.com/alpaca-tc/alpaca_powertabline">alpaca_powertabline</a></h2>

<p><img class="image_on_frame center <a" src="href="https://github-camo.global.ssl.fastly.net/8a63810a39b08548c3ce51a796f589b79d9df4be/687474703a2f2f662e636c2e6c792f6974656d732f31443430317630553355306f336733553054306e2f616c706163615f7461626c696e652e706e67">https://github-camo.global.ssl.fastly.net/8a63810a39b08548c3ce51a796f589b79d9df4be/687474703a2f2f662e636c2e6c792f6974656d732f31443430317630553355306f336733553054306e2f616c706163615f7461626c696e652e706e67</a>" title="alpaca_powertabline" ></p>

<p>tablineをpowerline化したプラグインです。</p>

<p>初めてのVim Advent Calendarで<a href="http://qiita.com/alpaca_taichou/items/ab70f914a6a577e25d70">powerlineをいつ使う？今でしょ！</a>という記事を書いて、そこそこ人気な記事となり驚きました。</p>

<p>いやぁ&hellip;<em>「今でしょ！」</em>って、もうさぶいねぇ。笑</p>

<p>初対面の人で、「使っているよ！」と言ってもらえることもあって嬉しかったです。</p>

<p>今年はlightlineやvim-airlineが登場したので、statusline系の変化が大きかった年だとと思います。</p>

<h2><a href="https://github.com/alpaca-tc/alpaca_english.git">alpaca_english</a></h2>

<p>SQLiteの英和辞書を利用して、英語の補完をするプラグインです。Uniteを通じて、類義語検索や例文検索を行うこともできます。</p>

<p><img class="image_on_frame center <a" src="href="https://github-camo.global.ssl.fastly.net/cb17a71ffad0a656d3a2837fe4c216a50524c2e4/687474703a2f2f636c2e6c792f696d6167652f316c316c306732373249314e2f254533253832254239254533253832254146254533253833254141254533253833254243254533253833254233254533253832254237254533253833254137254533253833253833254533253833253838253230323031332d30342d3231253230382e33372e33392e706e67">https://github-camo.global.ssl.fastly.net/cb17a71ffad0a656d3a2837fe4c216a50524c2e4/687474703a2f2f636c2e6c792f696d6167652f316c316c306732373249314e2f254533253832254239254533253832254146254533253833254141254533253833254243254533253833254233254533253832254237254533253833254137254533253833253833254533253833253838253230323031332d30342d3231253230382e33372e33392e706e67</a>" title="alpaca_english_demo" ></p>

<p>これを書き始めたときに、勇気を出してlingrで発言しはじめました。+Ruby環境のバグをVim-JP報告したのもこのプラグインがきっかけですね。</p>

<p>右も左も分からず、色んな人に助けてもらいました。ありがたや、ありがたや。</p>

<p>Vimプラグインを書き始めたときなので、哀愁の漂うコードです。あぁ、そろそろリファクタリングしないと！</p>

<h2><a href="https://github.com/alpaca-tc/beautify.vim.git">Beautify.vim</a></h2>

<p>整形・変換を行うプラグインです。糞便利。</p>

<p><img class="image_on_frame center <a" src="href="https://github.com/alpaca-tc/beautify.vim/blob/master/assets/02.gif?raw=true">https://github.com/alpaca-tc/beautify.vim/blob/master/assets/02.gif?raw=true</a>" title="beautify.vim demo" ></p>

<p>CSS-SCSS, JS-Coffeeなどの相互変換や、圧縮されたJS/CSSの整形などはお手の物です。</p>

<h2><a href="https://github.com/alpaca-tc/alpaca_tags">alpaca_tags</a></h2>

<p>tagsの非同期生成、tag用のunite-sourceなど同封しています。糞便利。</p>

<p><img class="image_on_frame center <a" src="href="https://github-camo.global.ssl.fastly.net/78073a9b0ac11577ea47c5083da6511140968510/687474703a2f2f6769667a6f2e6e65742f744944774866325a41702e676966">https://github-camo.global.ssl.fastly.net/78073a9b0ac11577ea47c5083da6511140968510/687474703a2f2f6769667a6f2e6e65742f744944774866325a41702e676966</a>" title="alpaca_tags.demo" ></p>

<p>京都のCamphorでの勉強会で初めてお披露目したので、あのメンバーと出会ったのもこれを作った時期だった気がする。いつだっけ。。</p>

<h2><a href="https://github.com/alpaca-tc/alpaca_octopress.vim">alpaca_octopress</a></h2>

<p>最近作った、Octopressの操作を非同期で実行するプラグインです。糞b</p>

<p><code>:Octopress preview</code>や<code>:Octopress gen_deploy</code>といった操作が非同期で行えるのが素晴らしい。</p>

<p>記事を書くのが随分楽になりました^^</p>

<h2><a href="https://github.com/alpaca-tc/vim-unite-watson.vim">vim-unite-watson.vim</a></h2>

<p><a href="http://goosecode.com/watson/">watson</a>用のUnite-sourceです。海外の方にも結構使ってもらえているようです。</p>

<h3>その他、今年作ったプラグイン</h3>

<ul>
<li><a href="https://github.com/alpaca-tc/alpaca_remove_dust.vim">alpaca_remove_dust.vim</a></li>
<li><a href="https://github.com/alpaca-tc/alpaca_window.vim">alpaca_window.vim</a></li>
<li><a href="https://github.com/alpaca-tc/assignment">assignment</a></li>
<li><a href="https://github.com/alpaca-tc/neorspec.vim">neorspec.vim</a></li>
<li><a href="https://github.com/alpaca-tc/lang-8.vim">lang-8.vim</a></li>
<li><a href="https://github.com/alpaca-tc/rake.vim">rake.vim</a></li>
<li><a href="https://github.com/alpaca-tc/snail.vim">snail.vim</a></li>
<li><a href="https://github.com/alpaca-tc/unite-git-aliases">unite-git-aliases</a></li>
<li><a href="https://github.com/alpaca-tc/documentation">documentation</a></li>
</ul>


<h2>まとめ</h2>

<p>Vimプラグインを通じて、一杯勉強させてもらえていたようです。Vim力もだいぶ上がりました。</p>

<p>来年はVim本体をガシガシいじっていきたいと思います・T・</p>

<p>さて、自分の作ったVimプラグインを振り返ると、Vimとともに一年の思い出が振り返れるようです！</p>

<p><strong>ぜひ、他のVimmerもお試しあれ！</strong></p>

<p><em>P.S.</em></p>

<p>ほぼVimの記事だけで、Qiitaのストック数が1,000に到達しました。わーい。(白目)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim中級者を脱する path編]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/jump-to-gem-path.html"/>
    <updated>2013-12-19T08:02:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/jump-to-gem-path</id>
    <content type="html"><![CDATA[<p>はい、pathとは<code>:set path</code>で出てくるやつのことです。
実際にはみなさん<code>gf</code>やファイル補完などでお世話になっていると思います。</p>

<p>今回はpathとは何かを説明して、.rbファイルのクラスからGemの定義元へ飛ぶ方法をやってみましょう。</p>

<!-- more -->


<p><strong>方法だけ知りたい人は、一番下までスクロールしてください</strong></p>

<h1>pathとは？</h1>

<p>Vimにおけるpathとは、<code>set path?</code>で出てくるpathです。</p>

<p>適当にファイルを開いてコマンドを打ってみましょう。</p>

<p><code>vim
:set path?
path=.,/usr/include
</code></p>

<p>これを設定しておくことで何が嬉しいかというと、編集中の変数の定義元へ飛べたり、ファイルを検索出来たりします。つまるところ、Vimが<em>何かを探すときの基準になる</em>ディレクトリ達を指定することができます。</p>

<p>補完プラグインや、Vimの基本機能などもpathに依存していることが多いため、裏側では結構活躍している設定でもあります。</p>

<h2><code>gf</code>でGemの定義元に飛ぶ</h2>

<p><code>gf</code>は通常、カーソル</p>

<p>Rubyを編集する際、Vimのビルトインの<code>ftplugin/ruby.vim</code>が読み込まれ、<code>gf</code>が自動的に関数にマッピングされます。</p>

<p><code>vim
:set filetype=ruby
:nmap gf
n  gf          *@:&lt;C-U&gt;exe &lt;SNR&gt;121_gf(v:count1,"gf",'edit')&lt;CR&gt;
</code></p>

<p>このおかげで、通常の<code>gf</code>が拡張されて幾つかのケースで<code>gf</code>が使えるようになります。(Rails.vimも同じ手法を使っていますね。)</p>

<p>具体的には<code>require 'path/to/file'</code>やload, autoloadで書いたファイルパスへ飛ぶことができます。</p>

<p>内部では拡張子を取り除いたり、ファイル名に不要な文字を変換したりしていますが、そのオプションについては、今回は割愛します。</p>

<h3>pathにRubyのload_pathを追加する</h3>

<p>Rubyを編集中に、Gemの定義元へ移動する話をしましょう。</p>

<p>まずRubyについて理解しておく必要があるのは、load_pathの仕組みです。Rubyは<code>require</code>などを使用したときに、指定されたファイルを<code>$LOAD_PATH</code>のディレクトリ一覧の中から探します。</p>

<p>下記のようなコマンドを打つことで、デフォルトの$LOAD_PATHを探すことができます。</p>

<p><code>ruby
ruby -e 'puts $LOAD_PATH'
</code></p>

<p>Gemfileを定義した場合、この$LOAD_PATHにそれらのGemの場所が追加されるので<code>require</code>で使うことがきるようになるんですね。</p>

<p>それでは、VimにもGemfileから取ってきたディレクトリ一覧を与えてやることで、定義元を探し出せるようにしましょう。</p>

<h3>Gemfileからディレクトリ一覧を取り出す</h3>

<p><code>bundle show --paths</code>を使うことで、一覧情報を取り出せます。</p>

<p><code>
$ bundle show --paths
/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/RedCloth-4.2.9
/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/bundler-1.3.5
/Users/alpaca-tc/.rbenv/versions/2.0.0-p247/lib/ruby/gems/2.0.0/gems/chunky_png-1.2.5
...
</code></p>

<p>この情報を<code>setl path=...</code>と与えてやれば、<code>gf</code>を使って定義元に飛べるようになります。</p>

<h3><code>set path=</code>を使って定義する</h3>

<p><a href="https://gist.github.com/8031905">こちらのスクリプト</a>をvimrcに貼付けましょう。<a href="https://github.com/vim-jp/vital.vim">vital.vim</a>依存です(unite.vim, neocompleteがあれば動作します)</p>

<p>これで、GemPathを読み込む<code>:LoadGem</code>というコマンドが作られます。</p>

<p>下記のような動作で定義元に飛べるのが確認できると思います。</p>

<p><img class="image_on_frame center" src="/images/blog/jump-to-gem-path/hM4zx40RmT.gif" title="gemジャンプデモ" ></p>

<p>無事動いていますね。</p>

<h2>まとめ</h2>

<p>今回はpathについて、簡単に説明しました。</p>

<p>次回は、pathを活用してさらに<code>include</code>, <code>includeexpr</code>あたりをやります。</p>

<p>この辺を勉強すると、自分の環境用にファイル補完を作り上げられます。 neocompleteのfile/includeあたりが書けるようになりますよ〜</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仕事が捗る！VimからGitを使う最適解]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/how-to-use-vim-unite-giti.html"/>
    <updated>2013-12-17T23:36:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/how-to-use-vim-unite-giti</id>
    <content type="html"><![CDATA[<p>先日の記事でもチラッと出てきた<a href="https://github.com/kmnk/vim-unite-giti">vim-unite-giti</a>というプラグインがあります。</p>

<p><strong>ものすごーーーく便利</strong>なプラグインなんですが、何故かほとんど話を聞かないプラグインです。</p>

<p>先日の記事でも、git系のプラグインは「知らなかった」という話を沢山聞きました。せっかくなので使い方を紹介します。</p>

<!-- more -->


<h2>今回紹介するのはvim-unite-giti!!</h2>

<p>何はともあれ、<strong>まずは動画をみてくれ。</strong></p>

<p><iframe width="560" height="420" src="http://www.youtube.com/embed/jCgcpIO9oBs?color=white&theme=light"></iframe></p>

<p>とにかく、uniteインターフェースは操作を覚えることが少ない。</p>

<p>今回も、幾つかのUniteコマンドを使っているけれど、基本的に「選択」→「アクション」の動作しかない。</p>

<h3>:Unite giti/status</h3>

<p>add, unstage, checkoutなどの操作が簡単ですね</p>

<p>conflictがあれば、すぐ見れます。「選択」→「commitアクション」と進めば、指定したファイルだけのコミットもお手軽に作れます(!!)</p>

<h3>:Unite giti/branch</h3>

<p>tracking, chckout, deleteなどの操作が簡単ですね。</p>

<p>branchを切るのにわざわざShellを使うなんて。あなた、Vimと触れ合う時間が減ってしまうではないですか。</p>

<h3>:Unite giti/log</h3>

<p>紹介していませんが、普通に便利です。vimdiffなどを見る事も簡単です。</p>

<h2>vim-unite-giti以外のプラグイン</h2>

<h3><em>git-vim</em> :GitDiff, :Git push</h3>

<p>こちらは、特に驚きはないので初めて使う人以外は見なくてもいいです。</p>

<p><iframe width="560" height="420" src="http://www.youtube.com/embed/wWI3Wb-0Vw4?color=white&theme=light"></iframe></p>

<p>言わずもがな、コマンド名の通りです。</p>

<p>git-vimを使って何がうれしいかと言うと、それなりに補完ができる点です。</p>

<h3><em>fugitive</em> :Gcommit, :Gblame</h3>

<p>すでに語り尽くされているので、ここでは取り上げません。</p>

<p>他のプラグインにもにたようなコマンドがありますが、色付きなのと、機能性が優れているのでfugitiveがおすすめです。</p>

<h2>vimrc</h2>

<p>今回の動画で使用したvimrcと同じような設定です</p>

<p><a href="https://gist.github.com/qickstarter/8008989">vimrc Gist</a></p>

<h2>まとめ</h2>

<p>ujihisaさんに憧れてのYoutube記事です。笑</p>

<p>余談ですが、作者の<a href="https://github.com/kmnk">kmnk</a>さんのコードは<strong>めちゃくちゃ奇麗</strong>です。</p>

<p>今までで読んできた中で、<em>一番奇麗なVimLのコード</em>でした。ほどよい抽象化、適切な命名、整理されたファイル達。率直に、この人と一緒に仕事出来る人は幸せだろうなぁと感じました。</p>

<p>vim-unite-gitiを作ってくださって感謝します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unite.vimとwatsonを使ったワークフロー]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/using-vim-unite-watson.html"/>
    <updated>2013-12-13T02:29:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/using-vim-unite-watson</id>
    <content type="html"><![CDATA[<p>最近、vim-unite-watsonを開発しました。</p>

<p>これが、watsonの作者であるnhmoodさんにも好評で、僕自身ワークフローが変化して、だいぶ作業しやすくなりました。</p>

<p>今回は、タスク管理をしたい人向けに、僕なりのワークフロー管理を紹介します。</p>

<!-- more -->


<h1>ワークフローとVim</h1>

<p>僕は普段、Webサービスの構築・保守を行う仕事をしています。</p>

<p>そこでは、基本的なフローは次のような流れです。</p>

<ol>
<li>新機能・バグに対してIssueを発行する(あるいは既にTODOリストにある)</li>
<li>トピックブランチを作る</li>
<li>コードを書く</li>
<li>コミット &ndash;> Pull-Requestを送る &ndash;> マージする</li>
</ol>


<p>では、Vimを一度も閉じることなくこれらの作業をしてみます。</p>

<h2>1. Issueの発行</h2>

<h3>1-1. TODOをコードに入力する</h3>

<p><img class="image_on_frame center" src="/images/blog/workflow_1.png" title="本番環境用にViewを作成すると記入する" ></p>

<h3>1-2. IssueをGithubにあげる</h3>

<p>インラインIssue管理の<a href="/blog/ruby/how-to-use-watson.html">watson</a>を使って、GithubにIssueをあげます</p>

<p><img class="image_on_frame center" src="/images/blog/workflow_2.png" title=":Watsonのデモ" ></p>

<p>Watsonを使えば、Vimから簡単にIssue管理を行うことが出来ますね。</p>

<h2>2. 作業の目処を立てる</h2>

<p>さて、これでIssueは挙げられたので、次はコードの改修をしていきます。</p>

<h3>2-1. トピックブランチを作る</h3>

<p>ブランチの作業は、<a href="https://github.com/alpaca-tc/vim-unite-giti">vim-unite-giti</a>を使います。</p>

<p><code>vim
:Unite giti/branch
</code></p>

<p>新しいブランチの名前を入力して、<code>[checkout branch]</code>の行を選択します。</p>

<p><img class="image_on_frame center" src="/images/blog/workflow_3.png" title="Unite gitiのデモ" ></p>

<p>すると、新しいブランチが作られました。</p>

<h3>2-2. コードの改修を行う場所に印をつけて行く</h3>

<p>コードの改修は、多くの場合幾つかのファイルに跨がります。</p>

<p>そのため、経験から作業が必要な箇所に目処をつけて、コメントを書いて行きます。</p>

<p><img class="image_on_frame center" src="/images/blog/workflow_4.png" title="" ></p>

<p><img class="image_on_frame center" src="/images/blog/workflow_5.png" title="" ></p>

<p><img class="image_on_frame center" src="/images/blog/workflow_6.png" title="" ></p>

<p>todoの内容は、watsonによって管理されるので、vim-unite-watsonを使えば一覧としてみることができます。</p>

<p><code>vim
:Unite watson/dirty
</code></p>

<p><img class="image_on_frame center" src="/images/blog/workflow_7.png" title="unite-watsonのdemo" ></p>

<p>これで、issueを解決するために必要な作業の一覧を自分で作ることが出来ました。</p>

<p>Unite上のコメントを選択すると、該当箇所に飛べます。</p>

<p>後は、</p>

<ol>
<li>該当箇所に飛ぶ</li>
<li>コードを修正する</li>
<li>解決したら、コメントを削除する</li>
</ol>


<p>を<code>:Unite watson/dirty</code>が空になるまで繰り返します。</p>

<p>watsonの結果リストが空になれば、issueの問題を解決したことになり、次の作業に移ります。</p>

<h3>3. GithubにPull-Requestする</h3>

<p>これは、各々方法が分かれるかと思います。</p>

<p>Vimから出ないでPull-Requestを送るには、<code>:!git push</code> &amp;&amp; <code>:!hub pull-request -h ...</code>というのが一番分かりやすいでしょうか。</p>

<p>僕は、<code>:Unite giti/pull_request</code>で送るようにしています。</p>

<h2>まとめ</h2>

<p>Watsonやgitiはかなり便利です。</p>

<p>特に、watsonはコーディング作業をマネジメントしたい人に向いていると思います。
作業時間の見積もりや、タスク管理を考えながらコーディングする人には向いているプラグインなのではないでしょうか。</p>

<p>僕は経営学部にいるので、すっかりタスク管理や時間計測を気にしちゃうようになりました。。</p>

<p><strong>今回紹介したプラグイン</strong></p>

<ul>
<li><a href="https://github.com/alpaca-tc/vim-unite-watson.vim">vim-unite-watson</a></li>
<li><a href="https://github.com/kmnk/vim-unite-giti">vim-unite-giti (本家)</a></li>
<li><a href="https://github.com/alpaca-tc/vim-unite-giti">vim-unite-giti (giti/pull_request追加版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NeoComplete vs YouCompleteMe]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/neocomplete-vs-youcompleteme.html"/>
    <updated>2013-12-10T00:04:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/neocomplete-vs-youcompleteme</id>
    <content type="html"><![CDATA[<p>この記事は<a href="http://atnd.org/events/45072">Vim Advent Calendar 2013</a>の10日目です。</p>

<p>先日は<a href="https://twitter.com/Linda_pp">@Linda</a>さんの<a href="http://rhysd.hatenablog.com/entry/2013/12/09/001219">無数のパッチを組み合わせて君だけの MacVim を作ろう！</a>でした。</p>

<p>大学卒業までに、自分専用Vimを作ろうと思っている自分にとって大変参考になる記事でした。</p>

<h1>NeoComplete VS YouCompleteMe</h1>

<p>さてさて、本日のAdvent CalendarではVimの補完プラグインの2大巨頭を比較してみようと思います。</p>

<!-- more -->


<ul>
<li><a href="https://github.com/Shougo/neocomplete.vim">NeoComplete</a> &ndash; (Shougoさん作)</li>
<li><a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a> &ndash; (Valloricさん作)</li>
</ul>


<p>元々、僕は<strong>大のShougo wareファン</strong>です。(Sourceや、本体への貢献も少ししています)</p>

<p>そんな僕もVimを探求する気持ちから、ついYouCompleteMeに手を出してしまいました!!!</p>

<p><strong>「は&hellip;速いぞこいつ！！」</strong></p>

<p>その補完速度の衝撃さることながら、他にも素晴らしいことが。</p>

<p>つい、NeoCompleteからの乗り換えが脳裏をよぎり、2週間使ってみることにしました。</p>

<h2>何について書くの？</h2>

<p>結論から言うと、NeoCompleteに戻ってきました。</p>

<p>しかし、<strong>NeoCompleteに改善の余地がある</strong>ことに気付きました。</p>

<p>「YCMのここが良かったから、NeoCompleteに取り入れよう！」という話をしたいと思います。</p>

<h2>YouCompleteMeの良かった点</h2>

<ul>
<li><strong>補完が早い</strong></li>
<li><strong>ファイル補完</strong>が素晴らしい</li>
<li>設定がほぼ不要</li>
<li>jedi.vim / clang-completeとの連携が容易</li>
<li>fuzzy補完が使いやすい！</li>
<li>YCM、と略しやすい。←</li>
</ul>


<p>補完スピードに関しては、感動しました。</p>

<h3>ファイル補完機能</h3>

<p>特筆すべきはファイル補完機能についてです。</p>

<p>使ってわかる、YCMのファイル補完の素晴らしさ。</p>

<p><img class="image_on_frame center" src="/images/blog/file_complete.png" title="YCMのファイル補完機能" ></p>

<ul>
<li>&ldquo;[Dir], [File]"で、補完候補の種類を入力している</li>
<li>ファイル補完時、バッファ補完などのノイズが入らない</li>
</ul>


<p>今まで、NeoCompleteで満足していたんですが、YCMを使って初めて改善の余地があることに気付きました。</p>

<h2>YouCompleteMeの悪かった点</h2>

<ul>
<li>補完の種類が少ない</li>
<li>カスタマイズができない。</li>
<li>補完候補の<code>dup</code>フラグが全てオン</li>
</ul>


<p>いや、一応カスタマイズしてNeoCompleteの移植できたんですけどね。疲れました。</p>

<h2>NeoCompleteを改善する</h2>

<p>さて、YCMを使って2週間。良いところをいくつか取り入れましょう。</p>

<p><strong>(追記: ファイル補完に関する修正は、本家に取り込まれました)</strong></p>

<h3>1. file補完のノイズを改善する</h3>

<p>デフォルトのNeoCompleteのfile補完のrankが低いため、ファイル補完時に他の候補が上にきてしまいます。</p>

<p>ファイル補完の優先順位をあげましょう。</p>

<p><code>vim
call neocomplete#custom#source('file', 'rank', 10)
</code></p>

<p>これに関しては、<strong>元々のファイル補完のrankがなぜ低いのか疑問</strong>です。理由があるのでしょうか。</p>

<h3>2. file補完で[Dir], [File]を表示する</h3>

<p>NeoCompleteに<a href="https://gist.github.com/qickstarter/7872458">パッチ</a>をあてます。</p>

<p>これで、YouCompleteMeと同じファイル補完を実現できます。</p>

<h3>3. 補完速度を向上する</h3>

<p>YCMでは、補完が少し止まる感覚が一切ありませんでした。</p>

<p>NeoCompleteはsourceを駆け巡って、頑張って補完候補を取得しているのである程度は仕方ないです。</p>

<p>ただ、自分の環境にあわせれば、補完スピードはあがるはずです。</p>

<p>```vim
&ldquo; 極端な例ですが、下記のような操作で補完をチューニングできます</p>

<p>&ldquo; 補完を始めるキーワード長を長くする
let g:neocomplete#sources#syntax#min_keyword_length = 4
let g:neocomplete#auto_completion_start_length = 4</p>

<p>&ldquo; 補完が止まった際に、スキップする長さを短くする
let g:neocomplete#skip_auto_completion_time = &lsquo;0.2&rsquo;</p>

<p>&ldquo; 使用する補完の種類を減らす
&rdquo; 現在のSourceの取得は <code>:echo keys(neocomplete#variables#get_sources())</code>
&ldquo; デフォルト: [&lsquo;file&rsquo;, &lsquo;tag&rsquo;, &lsquo;neosnippet&rsquo;, &lsquo;vim&rsquo;, &lsquo;dictionary&rsquo;, &lsquo;omni&rsquo;, &lsquo;member&rsquo;, &lsquo;syntax&rsquo;, &lsquo;include&rsquo;, &lsquo;buffer&rsquo;, &lsquo;file/include&rsquo;]
let g:neocomplete#sources = {
  \ &lsquo;_&rsquo; : [&lsquo;vim&rsquo;, &lsquo;omni&rsquo;, &lsquo;include&rsquo;, &lsquo;buffer&rsquo;, &lsquo;file/include&rsquo;]
  \ }</p>

<p>&ldquo; 特定のタイミングでのみ使う補完は、直接呼び出すようにする
inoremap <expr>&lt;C-X>&lt;C-F>  neocomplete#start_manual_complete(&lsquo;file&rsquo;)
inoremap <expr>&lt;C-X>&lt;C-K>  neocomplete#start_manual_complete(&lsquo;dictionary&rsquo;)
inoremap <expr>&lt;C-X>s      neocomplete#start_manual_complete(&lsquo;neosnippet&rsquo;)
```</p>

<h2>まとめ</h2>

<p>浮気して、彼女の良さに気付くパターンです。</p>

<p>YCMを使って気付きました。なんだかんだ<strong>NeoCompleteが最高</strong>ですね！！</p>
]]></content>
  </entry>
  
</feed>



