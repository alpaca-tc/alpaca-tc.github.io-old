<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | RailsとRubyとVimのブログ]]></title>
  <link href="http://alpaca-tc.github.io/blog/vim/atom.xml" rel="self"/>
  <link href="http://alpaca-tc.github.io/"/>
  <updated>2013-12-18T02:17:37+09:00</updated>
  <id>http://alpaca-tc.github.io/</id>
  <author>
    <name><![CDATA[alpaca-tc]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[仕事が捗る！VimからGitを使う最適解]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/how-to-use-vim-unite-giti.html"/>
    <updated>2013-12-17T23:36:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/how-to-use-vim-unite-giti</id>
    <content type="html"><![CDATA[<p>先日の記事でもチラッと出てきた<a href="https://github.com/kmnk/vim-unite-giti">vim-unite-giti</a>というプラグインがあります。</p>

<p><strong>ものすごーーーく便利</strong>なプラグインなんですが、何故かほとんど話を聞かないプラグインです。</p>

<p>先日の記事でも、git系のプラグインは「知らなかった」という話を沢山聞きました。せっかくなので使い方を紹介します。</p>

<!-- more -->


<h2>今回紹介するのはvim-unite-giti!!</h2>

<p>何はともあれ、<strong>まずは動画をみてくれ。</strong></p>

<p><iframe width="560" height="420" src="http://www.youtube.com/embed/jCgcpIO9oBs?color=white&theme=light"></iframe></p>

<p>とにかく、uniteインターフェースは操作を覚えることが少ない。</p>

<p>今回も、幾つかのUniteコマンドを使っているけれど、基本的に「選択」→「アクション」の動作しかない。</p>

<h3>:Unite giti/status</h3>

<p>add, unstage, checkoutなどの操作が簡単ですね</p>

<p>conflictがあれば、すぐ見れます。「選択」→「commitアクション」と進めば、指定したファイルだけのコミットもお手軽に作れます(!!)</p>

<h3>:Unite giti/branch</h3>

<p>tracking, chckout, deleteなどの操作が簡単ですね。</p>

<p>branchを切るのにわざわざShellを使うなんて。あなた、Vimと触れ合う時間が減ってしまうではないですか。</p>

<h3>:Unite giti/log</h3>

<p>紹介していませんが、普通に便利です。vimdiffなどを見る事も簡単です。</p>

<h2>vim-unite-giti以外のプラグイン</h2>

<h3><em>git-vim</em> :GitDiff, :Git push</h3>

<p>こちらは、特に驚きはないので初めて使う人以外は見なくてもいいです。</p>

<p><iframe width="560" height="420" src="http://www.youtube.com/embed/wWI3Wb-0Vw4?color=white&theme=light"></iframe></p>

<p>言わずもがな、コマンド名の通りです。</p>

<p>git-vimを使って何がうれしいかと言うと、それなりに補完ができる点です。</p>

<h3><em>fugitive</em> :Gcommit, :Gblame</h3>

<p>すでに語り尽くされているので、ここでは取り上げません。</p>

<p>他のプラグインにもにたようなコマンドがありますが、色付きなのと、機能性が優れているのでfugitiveがおすすめです。</p>

<h2>vimrc</h2>

<p>```vim
&ldquo; コピペで貼付けているので、これで動作しなかったら賢く書き換えてください。
NeoBundleLazy &lsquo;kmnk/vim-unite-giti&rsquo;, {</p>

<pre><code>  \ 'autoload': {
  \   'unite_sources': [
  \     'giti', 'giti/branch', 'giti/branch/new', 'giti/branch_all',
  \     'giti/config', 'giti/log', 'giti/remote', 'giti/status'
  \   ]
  \ }}
</code></pre>

<p>NeoBundleLazy &lsquo;Shougo/git-vim&rsquo;, {</p>

<pre><code>  \ 'autoload' : {
  \ 'function_prefix' : 'git',
  \ 'functions' : 'git#get_current_branch',
  \ 'commands': [
  \   { 'name': 'GitDiff',     'complete' : 'customlist,git#list_commits' },
  \   { 'name': 'GitVimDiff',  'complete' : 'customlist,git#list_commits' },
  \   { 'name': 'Git',         'complete' : 'customlist,git#list_commits' },
  \   { 'name': 'GitCheckout', 'complete' : 'customlist,git#list_commits' },
  \   { 'name': 'GitAdd',      'complete' : 'file' },
  \   'GitLog', 'GitCommit', 'GitBlame', 'GitPush'] }}
</code></pre>

<p>NeoBundleLazy &lsquo;tpope/vim-fugitive&rsquo;, { &lsquo;autoload&rsquo;: {</p>

<pre><code>  \ 'functions' : ['fugitive#head', 'fugitive#detect'],
  \ 'commands': ['Gcommit', 'Gblame', 'Ggrep', 'Gdiff', 'Gcd'] }}
</code></pre>

<p>&ldquo; git-vim
let g:git_bin = executable(&lsquo;hub&rsquo;) ? &lsquo;hub&rsquo; : &lsquo;git&rsquo;
let g:git_command_edit = &lsquo;vnew&rsquo;
let g:git_no_default_mappings = 1
nnoremap gA :&lt;C-U>GitAdd<Space>
nnoremap <silent>ga :&lt;C-U>GitAdd<CR>
nnoremap gp :&lt;C-U>Git push<Space>
nnoremap gD :&lt;C-U>GitDiff<Space>
nnoremap gDD :&lt;C-U>GitDiff HEAD<CR>
nnoremap git :&lt;C-U>Git<Space></p>

<p>&ldquo; fugitive
nnoremap <silent>gM :Gcommit &mdash;amend<CR>
nnoremap <silent>gb :Gblame<CR>
nnoremap <silent>gB :Gbrowse<CR>
nnoremap <silent>gm :Gcommit<CR>
let hooks = neobundle#get_hooks(&lsquo;vim-fugitive&rsquo;)
function! hooks.on_source(bundle)
  augroup MyGitCmd</p>

<pre><code>autocmd!
autocmd FileType fugitiveblame vertical res 25
autocmd FileType gitcommit,git-diff nnoremap &lt;buffer&gt;q :q&lt;CR&gt;
</code></pre>

<p>  augroup END</p>

<p>  let g:fugitive_git_executable = executable(&lsquo;hub&rsquo;) ? &lsquo;hub&rsquo; : &lsquo;git&rsquo;
endfunction
function! hooks.on_post_source(bundle)
  call fugitive#detect(expand(&lsquo;<amatch>:p&rsquo;))
endfunction
command! FugitiveReload call fugitive#detect(expand(&lsquo;<amatch>:p&rsquo;))
unlet hooks</p>

<p>&ldquo; vim-unite-giti
nnoremap <silent>gl :Unite giti/log -no-start-insert -horizontal<CR>
nnoremap <silent>gP :Unite giti/pull_request/base -no-start-insert -horizontal<CR>
nnoremap <silent>gs :Unite giti/status -no-start-insert -horizontal<CR>
nnoremap <silent>gh :Unite giti/branch_all -no-start-insert<CR></p>

<p>augroup MyUniteCmd
  autocmd!
  autocmd FileType unite call <SID>unite_my_settings()
augroup END</p>

<p>function s:unite_my_settings()
  let profile_name = substitute(unite#get_current_unite().profile_name, &lsquo;[&ndash;/]&rsquo;, &lsquo;_&rsquo;, &lsquo;g&rsquo;)
  if !empty(profile_name) &amp;&amp; has_key(s:unite_hooks, profile_name)</p>

<pre><code>call s:unite_hooks[profile_name]()
</code></pre>

<p>  endif
endfunction</p>

<p>let s:unite_hooks = {}
function! s:unite_hooks.source_giti_status()
  &ldquo; nnoremap <silent><buffer><expr>gM unite#do_action(&lsquo;ammend&rsquo;)
  &rdquo; nnoremap <silent><buffer><expr>gm unite#do_action(&lsquo;commit&rsquo;)
  nnoremap <silent><buffer><expr>ga unite#do_action(&lsquo;stage&rsquo;)
  nnoremap <silent><buffer><expr>gc unite#do_action(&lsquo;checkout&rsquo;)
  nnoremap <silent><buffer><expr>gd unite#do_action(&lsquo;diff&rsquo;)
  nnoremap <silent><buffer><expr>gu unite#do_action(&lsquo;unstage&rsquo;)
endfunction</p>

<p>function! s:unite_hooks.source_giti_branch()
  nnoremap <silent><buffer><expr>d unite#do_action(&lsquo;delete&rsquo;)
  nnoremap <silent><buffer><expr>D unite#do_action(&lsquo;delete_force&rsquo;)
endfunction</p>

<p>function! s:unite_hooks.source_giti_branch_all()
  call s:unite_hooks.source_giti_branch()
endfunction</p>

<p>function! s:unite_hooks.source_giti_log()
  nnoremap <silent><buffer><expr>gd unite#do_action(&lsquo;diff&rsquo;)
  nnoremap <silent><buffer><expr>d unite#do_action(&lsquo;diff&rsquo;)
endfunction
```</p>

<h2>まとめ</h2>

<p>ujihisaさんに憧れてのYoutube記事です。笑</p>

<p>余談ですが、作者の<a href="https://github.com/kmnk">kmnk</a>さんのコードは<strong>めちゃくちゃ奇麗</strong>です。</p>

<p>今までで読んできた中で、<em>一番奇麗なVimLのコード</em>でした。ほどよい抽象化、適切な命名、整理されたファイル達。率直に、この人と一緒に仕事出来る人は幸せだろうなぁと感じました。</p>

<p>vim-unite-gitiを作ってくださって感謝します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unite.vimとwatsonを使ったワークフロー]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/using-vim-unite-watson.html"/>
    <updated>2013-12-13T02:29:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/using-vim-unite-watson</id>
    <content type="html"><![CDATA[<p>最近、vim-unite-watsonを開発しました。</p>

<p>これが、watsonの作者であるnhmoodさんにも好評で、僕自身ワークフローが変化して、だいぶ作業しやすくなりました。</p>

<p>今回は、タスク管理をしたい人向けに、僕なりのワークフロー管理を紹介します。</p>

<!-- more -->


<h1>ワークフローとVim</h1>

<p>僕は普段、Webサービスの構築・保守を行う仕事をしています。</p>

<p>そこでは、基本的なフローは次のような流れです。</p>

<ol>
<li>新機能・バグに対してIssueを発行する(あるいは既にTODOリストにある)</li>
<li>トピックブランチを作る</li>
<li>コードを書く</li>
<li>コミット &ndash;> Pull-Requestを送る &ndash;> マージする</li>
</ol>


<p>では、Vimを一度も閉じることなくこれらの作業をしてみます。</p>

<h2>1. Issueの発行</h2>

<h3>1-1. TODOをコードに入力する</h3>

<p><img class="image_on_frame center" src="/images/blog/workflow_1.png" title="本番環境用にViewを作成すると記入する" ></p>

<h3>1-2. IssueをGithubにあげる</h3>

<p>インラインIssue管理の<a href="/blog/ruby/how-to-use-watson.html">watson</a>を使って、GithubにIssueをあげます</p>

<p><img class="image_on_frame center" src="/images/blog/workflow_2.png" title=":Watsonのデモ" ></p>

<p>Watsonを使えば、Vimから簡単にIssue管理を行うことが出来ますね。</p>

<h2>2. 作業の目処を立てる</h2>

<p>さて、これでIssueは挙げられたので、次はコードの改修をしていきます。</p>

<h3>2-1. トピックブランチを作る</h3>

<p>ブランチの作業は、<a href="https://github.com/alpaca-tc/vim-unite-giti">vim-unite-giti</a>を使います。</p>

<p><code>vim
:Unite giti/branch
</code></p>

<p>新しいブランチの名前を入力して、<code>[checkout branch]</code>の行を選択します。</p>

<p><img class="image_on_frame center" src="/images/blog/workflow_3.png" title="Unite gitiのデモ" ></p>

<p>すると、新しいブランチが作られました。</p>

<h3>2-2. コードの改修を行う場所に印をつけて行く</h3>

<p>コードの改修は、多くの場合幾つかのファイルに跨がります。</p>

<p>そのため、経験から作業が必要な箇所に目処をつけて、コメントを書いて行きます。</p>

<p><img class="image_on_frame center" src="/images/blog/workflow_4.png" title="" ></p>

<p><img class="image_on_frame center" src="/images/blog/workflow_5.png" title="" ></p>

<p><img class="image_on_frame center" src="/images/blog/workflow_6.png" title="" ></p>

<p>todoの内容は、watsonによって管理されるので、vim-unite-watsonを使えば一覧としてみることができます。</p>

<p><code>vim
:Unite watson/dirty
</code></p>

<p><img class="image_on_frame center" src="/images/blog/workflow_7.png" title="unite-watsonのdemo" ></p>

<p>これで、issueを解決するために必要な作業の一覧を自分で作ることが出来ました。</p>

<p>Unite上のコメントを選択すると、該当箇所に飛べます。</p>

<p>後は、</p>

<ol>
<li>該当箇所に飛ぶ</li>
<li>コードを修正する</li>
<li>解決したら、コメントを削除する</li>
</ol>


<p>を<code>:Unite watson/dirty</code>が空になるまで繰り返します。</p>

<p>watsonの結果リストが空になれば、issueの問題を解決したことになり、次の作業に移ります。</p>

<h3>3. GithubにPull-Requestする</h3>

<p>これは、各々方法が分かれるかと思います。</p>

<p>Vimから出ないでPull-Requestを送るには、<code>:!git push</code> &amp;&amp; <code>:!hub pull-request -h ...</code>というのが一番分かりやすいでしょうか。</p>

<p>僕は、<code>:Unite giti/pull_request</code>で送るようにしています。</p>

<h2>まとめ</h2>

<p>Watsonやgitiはかなり便利です。</p>

<p>特に、watsonはコーディング作業をマネジメントしたい人に向いていると思います。
作業時間の見積もりや、タスク管理を考えながらコーディングする人には向いているプラグインなのではないでしょうか。</p>

<p>僕は経営学部にいるので、すっかりタスク管理や時間計測を気にしちゃうようになりました。。</p>

<p><strong>今回紹介したプラグイン</strong></p>

<ul>
<li><a href="https://github.com/alpaca-tc/vim-unite-watson.vim">vim-unite-watson</a></li>
<li><a href="https://github.com/kmnk/vim-unite-giti">vim-unite-giti (本家)</a></li>
<li><a href="https://github.com/alpaca-tc/vim-unite-giti">vim-unite-giti (giti/pull_request追加版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NeoComplete vs YouCompleteMe]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/neocomplete-vs-youcompleteme.html"/>
    <updated>2013-12-10T00:04:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/neocomplete-vs-youcompleteme</id>
    <content type="html"><![CDATA[<p>この記事は<a href="http://atnd.org/events/45072">Vim Advent Calendar 2013</a>の10日目です。</p>

<p>先日は<a href="https://twitter.com/Linda_pp">@Linda</a>さんの<a href="http://rhysd.hatenablog.com/entry/2013/12/09/001219">無数のパッチを組み合わせて君だけの MacVim を作ろう！</a>でした。</p>

<p>大学卒業までに、自分専用Vimを作ろうと思っている自分にとって大変参考になる記事でした。</p>

<h1>NeoComplete VS YouCompleteMe</h1>

<p>さてさて、本日のAdvent CalendarではVimの補完プラグインの2大巨頭を比較してみようと思います。</p>

<!-- more -->


<ul>
<li><a href="https://github.com/Shougo/neocomplete.vim">NeoComplete</a> &ndash; (Shougoさん作)</li>
<li><a href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a> &ndash; (Valloricさん作)</li>
</ul>


<p>元々、僕は<strong>大のShougo wareファン</strong>です。(Sourceや、本体への貢献も少ししています)</p>

<p>そんな僕もVimを探求する気持ちから、ついYouCompleteMeに手を出してしまいました!!!</p>

<p><strong>「は&hellip;速いぞこいつ！！」</strong></p>

<p>その補完速度の衝撃さることながら、他にも素晴らしいことが。</p>

<p>つい、NeoCompleteからの乗り換えが脳裏をよぎり、2週間使ってみることにしました。</p>

<h2>何について書くの？</h2>

<p>結論から言うと、NeoCompleteに戻ってきました。</p>

<p>しかし、<strong>NeoCompleteに改善の余地がある</strong>ことに気付きました。</p>

<p>「YCMのここが良かったから、NeoCompleteに取り入れよう！」という話をしたいと思います。</p>

<h2>YouCompleteMeの良かった点</h2>

<ul>
<li><strong>補完が早い</strong></li>
<li><strong>ファイル補完</strong>が素晴らしい</li>
<li>設定がほぼ不要</li>
<li>jedi.vim / clang-completeとの連携が容易</li>
<li>fuzzy補完が使いやすい！</li>
<li>YCM、と略しやすい。←</li>
</ul>


<p>補完スピードに関しては、感動しました。</p>

<h3>ファイル補完機能</h3>

<p>特筆すべきはファイル補完機能についてです。</p>

<p>使ってわかる、YCMのファイル補完の素晴らしさ。</p>

<p><img class="image_on_frame center" src="/images/blog/file_complete.png" title="YCMのファイル補完機能" ></p>

<ul>
<li>&ldquo;[Dir], [File]"で、補完候補の種類を入力している</li>
<li>ファイル補完時、バッファ補完などのノイズが入らない</li>
</ul>


<p>今まで、NeoCompleteで満足していたんですが、YCMを使って初めて改善の余地があることに気付きました。</p>

<h2>YouCompleteMeの悪かった点</h2>

<ul>
<li>補完の種類が少ない</li>
<li>カスタマイズができない。</li>
<li>補完候補の<code>dup</code>フラグが全てオン</li>
</ul>


<p>いや、一応カスタマイズしてNeoCompleteの移植できたんですけどね。疲れました。</p>

<h2>NeoCompleteを改善する</h2>

<p>さて、YCMを使って2週間。良いところをいくつか取り入れましょう。</p>

<p><strong>(追記: ファイル補完に関する修正は、本家に取り込まれました)</strong></p>

<h3>1. file補完のノイズを改善する</h3>

<p>デフォルトのNeoCompleteのfile補完のrankが低いため、ファイル補完時に他の候補が上にきてしまいます。</p>

<p>ファイル補完の優先順位をあげましょう。</p>

<p><code>vim
call neocomplete#custom#source('file', 'rank', 10)
</code></p>

<p>これに関しては、<strong>元々のファイル補完のrankがなぜ低いのか疑問</strong>です。理由があるのでしょうか。</p>

<h3>2. file補完で[Dir], [File]を表示する</h3>

<p>NeoCompleteに<a href="https://gist.github.com/qickstarter/7872458">パッチ</a>をあてます。</p>

<p>これで、YouCompleteMeと同じファイル補完を実現できます。</p>

<h3>3. 補完速度を向上する</h3>

<p>YCMでは、補完が少し止まる感覚が一切ありませんでした。</p>

<p>NeoCompleteはsourceを駆け巡って、頑張って補完候補を取得しているのである程度は仕方ないです。</p>

<p>ただ、自分の環境にあわせれば、補完スピードはあがるはずです。</p>

<p>```vim
&ldquo; 極端な例ですが、下記のような操作で補完をチューニングできます</p>

<p>&ldquo; 補完を始めるキーワード長を長くする
let g:neocomplete#sources#syntax#min_keyword_length = 4
let g:neocomplete#auto_completion_start_length = 4</p>

<p>&ldquo; 補完が止まった際に、スキップする長さを短くする
let g:neocomplete#skip_auto_completion_time = &lsquo;0.2&rsquo;</p>

<p>&ldquo; 使用する補完の種類を減らす
&rdquo; 現在のSourceの取得は <code>:echo keys(neocomplete#variables#get_sources())</code>
&ldquo; デフォルト: [&lsquo;file&rsquo;, &lsquo;tag&rsquo;, &lsquo;neosnippet&rsquo;, &lsquo;vim&rsquo;, &lsquo;dictionary&rsquo;, &lsquo;omni&rsquo;, &lsquo;member&rsquo;, &lsquo;syntax&rsquo;, &lsquo;include&rsquo;, &lsquo;buffer&rsquo;, &lsquo;file/include&rsquo;]
let g:neocomplete#sources = {
  \ &lsquo;_&rsquo; : [&lsquo;vim&rsquo;, &lsquo;omni&rsquo;, &lsquo;include&rsquo;, &lsquo;buffer&rsquo;, &lsquo;file/include&rsquo;]
  \ }</p>

<p>&ldquo; 特定のタイミングでのみ使う補完は、直接呼び出すようにする
inoremap <expr>&lt;C-X>&lt;C-F>  neocomplete#start_manual_complete(&lsquo;file&rsquo;)
inoremap <expr>&lt;C-X>&lt;C-K>  neocomplete#start_manual_complete(&lsquo;dictionary&rsquo;)
inoremap <expr>&lt;C-X>s      neocomplete#start_manual_complete(&lsquo;neosnippet&rsquo;)
```</p>

<h2>まとめ</h2>

<p>浮気して、彼女の良さに気付くパターンです。</p>

<p>YCMを使って気付きました。なんだかんだ<strong>NeoCompleteが最高</strong>ですね！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim中級者を脱する スコープ編]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/break-vim-beginners-scope.html"/>
    <updated>2013-11-13T17:26:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/break-vim-beginners-scope</id>
    <content type="html"><![CDATA[<p>個人的に、Vimで一番ハマったのが<strong>スコープの問題</strong>でした。</p>

<p>vimrcのコピペばかりの、あなた。</p>

<p>せめて、よく登場するスコープだけでも理解してみましょう。</p>

<!-- more -->


<h1>よく見るスコープ一覧</h1>

<ul>
<li><em>グローバル</em>スコープ　<code>g:</code></li>
<li><em>関数内</em>スコープ　<code>a:</code></li>
<li><em>スクリプト</em>スコープ　<code>s:</code></li>
<li><em>バッファ</em>スコープ　<code>b:</code></li>
<li><em>接頭辞なし</em>　<code>let huga=...</code>など</li>
</ul>


<h2>グローバル(g:)スコープ</h2>

<p><strong>どこからでも参照できます。</strong></p>

<p>プラグインの設定で見慣れたスコープですね。</p>

<p><code>let g:neocomplete#enable_at_startup = 1</code></p>

<p>変数を初期化するには、次のようにします。
大量のエラーコードによって操作できなくなるので、<strong>嫌いな人のvimrcの末尾に書き込んでください。</strong></p>

<p><code>vim
for key in keys(g:)
  execute 'unlet g:' . key
endfor
</code></p>

<h2>関数内(a:)スコープ</h2>

<p><strong>関数内で、引数を参照するときに使用するスコープ</strong></p>

<p>個人的に一番理解しがたいスコープです。</p>

<p>こんな感じで使います。他言語から移ってきた人には、正直使いづらい。</p>

<p>```
function! Huga(first, second)
  echo a:first
  &ldquo;=> &lsquo;a&rsquo;</p>

<p>  echo a:
  &ldquo;=> {&lsquo;0&rsquo;: 0, &lsquo;000&rsquo;: [], &lsquo;second&rsquo;: &lsquo;b&rsquo;, &lsquo;first&rsquo;: &lsquo;a&rsquo;, &lsquo;firstline&rsquo;: 5, &lsquo;lastline&rsquo;: 5}
endfunction</p>

<p>call Huga(&lsquo;a&rsquo;, &lsquo;b&rsquo;)
```</p>

<p>「あーなるほど、<strong>関数内でだけ有効なスコープなのか。</strong>」</p>

<p>と、思っていたら<em>それは間違い。</em></p>

<p>下記のようにすると、<strong>グローバルスコープとして参照できます。</strong></p>

<p>```vim
function! a:huga()
  echo &lsquo;Global!?!?!?&rsquo;
endfunction</p>

<p>call a:huga() &ldquo; => Global!?!?!?
```</p>

<p>実は、これ関数名に<code>:</code>が許可されているだけです。
なので実際は<code>a:</code>スコープは関係ないんだけど、分かりづらい。</p>

<h2>スクリプト(s:)スコープ</h2>

<p><strong>ファイル内でのみ有効なスコープ</strong>です。</p>

<p>プラグインで、プライベートなメソッドや定数を作るときによく使います。</p>

<p><code>vim
let s:script_scope = '外部からは参照できない'
function! s:script_scope_method()
  " プライベートメソッドとしてよく使われる
endfunction
</code></p>

<p>この<code>s:</code>は、スクリプトがsourceされるときに置き換えられ、<code>&lt;SNR&gt;1_...</code>という感じの形になります。</p>

<p>えぇ、そうです。すると、<strong>グローバルなスコープとして参照できます。</strong></p>

<p>この<code>&lt;SNR&gt;</code>の後にどの数値が割り振られているかは、<code>:scriptnames</code>で参照できます。</p>

<p>また、<code>s:</code>は<code>&lt;SID&gt;</code>として使えばスコープを超えて使用できるようになります。</p>

<p>マッピングの時に、scriptスコープを使う時などは必須ですね。</p>

<p><code>vim
nnoremap s :echo &lt;SID&gt;SID()&lt;CR&gt;
</code></p>

<p>ただし、<strong>変数は基本的には聖域</strong>です。</p>

<h2>バッファ(b:)スコープ</h2>

<p><strong>バッファ単位のスコープ</strong>です。</p>

<p>ファイルタイプによる設定や、一時バッファによる変数などに使います。</p>

<ul>
<li>ファイルタイプの変更で、<code>b:current_syntax</code>などが初期化&amp;格納されます</li>
<li>Uniteを起動で、<code>b:unite</code>にデータが格納されます。</li>
</ul>


<p>Uniteのデバッグするときには、<code>echo b:unite.candidates</code>などを参照しましょう。</p>

<p>あぁ、ようやくまともなスコープだ。</p>

<h2>接頭辞なし(<code>let huga=</code>)変数</h2>

<p>えぇ。<strong>グローバルなスコープです。</strong></p>

<p>お前もか！</p>

<p>マナーとしては、やはり<code>g:</code>で宣言したいところですが、</p>

<p>Vimにデフォルトで入っているプラグインは、容赦なくこの変数を使ってきます。</p>

<p><code>:echo loaded_*&lt;Tab&gt;</code>などすれば、奴らを見つけられるはずです。</p>

<p>細かいことを言えば、関数内ならばローカルスコープです。。。</p>

<h2>スコープのまとめ</h2>

<ul>
<li>スコープは<strong>ほとんどグローバルで参照できる</strong></li>
<li>VimLは枠にハマらない<strong>素敵な</strong>言語仕様を持っている</li>
<li>getbufvar()などでスコープへアクセス出来るため、<strong>聖域はほとんど無い</strong></li>
</ul>


<p><strong>正直今でも理解出来ていない。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript補完プラグインのTernはすごいヤツ]]></title>
    <link href="http://alpaca-tc.github.io/blog/vim/how-to-use-tern-vim.html"/>
    <updated>2013-11-13T14:40:00+09:00</updated>
    <id>http://alpaca-tc.github.io/blog/vim/how-to-use-tern-vim</id>
    <content type="html"><![CDATA[<p><strong>「え、JavaScriptを書いているのに、Tern使ってないの？」</strong></p>

<p>ダサい。イケてない。
あぁ、残念。</p>

<!-- more -->


<p><a href="https://github.com/marijnh/tern">Tern</a>は、marijnhという凄いエンジニアの人が作っている<strong>JavaScriptの動的補完プラグイン</strong></p>

<p>コードを動的にパースして、今カーソルがある変数の型まで調べて補完しちゃってくれる。</p>

<p>設定をすれば、jQueryなどのプラグインでの諸々も補完しちゃう凄いやつなのだ。</p>

<p>```vim
if has(&lsquo;python&rsquo;) &amp;&amp; executable(&lsquo;npm&rsquo;)
  NeoBundleLazy &lsquo;marijnh/tern_for_vim&rsquo;, {</p>

<pre><code>    \ 'build' : 'npm install',
    \ 'autoload' : {
    \   'functions': ['tern#Complete', 'tern#Enable'],
    \   'filetypes' : 'javascript'
    \ }}
</code></pre>

<p>endif
```</p>

<p>まぁ、何はともあれ一度使ってみてください。</p>
]]></content>
  </entry>
  
</feed>



